# Async/Await

**Async/await is syntactic sugar** for working with promises.

## Table of Contents
* [Async](#async-functions)
* [Await](#await)
* [Error Handling](#error-handling)

## Async functions

Let's start with the `async` keyword. If it appears before a function it means that function always returns a promise. Other values are wrapped in a resolved response automatically.

```javascript
async function test() {
    return 1;
}

f.then(alert); //1
```

## Await

The keyword `await` makes Javascript wait until a promise settles and returns its result. It needs to be used within `async` functions.

```javascript
async function test() {
    let promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve("1 second done!"), 1000)
    })

    let result = await promise; //waits for the promise instead of proceeding
    alert(result); // 1 second done!
}
```

With `await`, the function execution "pauses" athe line and resumes when the promise settles with result becoming `result`. 

What is happening here? `await` literally suspends the function execution until the promise settles, and then resumes it with the promise result. This doesn't block the CPU, because the JavaScript engine can do other jobs in the meantime.

## Error Handling

If a promise resolves normally, then `await` returns the result. In the case of a rejection, it throws the error, just as if there were a `throw` statement at that line.

There are typically two strategies for dealing with errors in async/await code.

1. use a try/catch block

```javascript
async function test() {
    try {
        let response = await fetch('some-endpoint');
        let user = await response.json();
    } catch(err) {
        //catches errors both in fetch and response.json
        alert(err);
    }
}

test();
```

2. Handle the promise generated by the `async` call with a `catch`.

```javascript
async function test() {
    let response = await fetch('that-thing');
}

f().catch(alert);

```